using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Morpeh.BoilerplateGenerationProcessor
{
    [Generator]
    public class AttributeGenerator : IIncrementalGenerator
    {
        private const string IComponentFullName = "Scellecs.Morpeh.IComponent";
        private const string Il2CppSetOptionAttributeFullName = "Unity.IL2CPP.CompilerServices.Il2CppSetOptionAttribute";

        private static readonly HashSet<string> MorpehSystemInterfaces = new HashSet<string>
        {
            "Scellecs.Morpeh.ISystem",
            "Scellecs.Morpeh.IInitializer",
            "Scellecs.Morpeh.IFixedSystem",
            "Scellecs.Morpeh.ILateSystem",
            "Scellecs.Morpeh.ICleanupSystem"
        };

        private static readonly DiagnosticDescriptor NonPartialTypeWarning = new DiagnosticDescriptor(
            id: "APC001",
            title: "Type Should Be Partial",
            messageFormat: "Type '{0}' is a Morpeh Component or System and should be declared 'partial' for automatic attribute generation",
            category: "Design",
            defaultSeverity: DiagnosticSeverity.Warning,
            isEnabledByDefault: true);

        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            var typeDeclarations = context.SyntaxProvider
                .CreateSyntaxProvider(
                    predicate: static (s, _) => s is TypeDeclarationSyntax,
                    transform: static (ctx, _) => GetTypeDeclarationForGeneration(ctx))
                .Where(static m => m is not null);

            context.RegisterSourceOutput(typeDeclarations,
                static (spc, source) => Execute(spc, source));
        }

        private static TypeDeclarationInfo? GetTypeDeclarationForGeneration(GeneratorSyntaxContext context)
        {
            var typeDeclarationSyntax = (TypeDeclarationSyntax)context.Node;

            if (typeDeclarationSyntax.Modifiers.Any(SyntaxKind.StaticKeyword))
            {
                return null;
            }

            var semanticModel = context.SemanticModel;
            var typeSymbol = semanticModel.GetDeclaredSymbol(typeDeclarationSyntax) as INamedTypeSymbol;

            if (typeSymbol is null || HasRequiredAttributes(typeSymbol))
            {
                return null;
            }

            bool isPartial = typeDeclarationSyntax.Modifiers.Any(SyntaxKind.PartialKeyword);

            var allInterfaces = new HashSet<string>(typeSymbol.AllInterfaces.Select(i => i.ToDisplayString()));
            bool isMorpehComponent = typeSymbol.TypeKind == TypeKind.Struct && allInterfaces.Contains(IComponentFullName);
            bool isMorpehSystem = typeSymbol.TypeKind == TypeKind.Class && allInterfaces.Overlaps(MorpehSystemInterfaces);

            if ((isMorpehComponent || isMorpehSystem) && !isPartial)
            {
                var diagnostic = Diagnostic.Create(NonPartialTypeWarning, typeDeclarationSyntax.GetLocation(), typeSymbol.Name);
                return new TypeDeclarationInfo(diagnostic);
            }

            if (isMorpehComponent || isMorpehSystem || isPartial)
            {
                string namespaceName = typeSymbol.ContainingNamespace.IsGlobalNamespace
                   ? string.Empty
                   : typeSymbol.ContainingNamespace.ToDisplayString();

                return new TypeDeclarationInfo(
                    typeDeclarationSyntax.Identifier.Text,
                    namespaceName,
                    GetParentClassHierarchy(typeDeclarationSyntax),
                    typeSymbol.IsValueType
                );
            }

            return null;
        }

        private static bool HasRequiredAttributes(INamedTypeSymbol typeSymbol) =>
            typeSymbol.GetAttributes().Any(a => a.AttributeClass?.ToDisplayString() == Il2CppSetOptionAttributeFullName);

        private static void Execute(SourceProductionContext context, TypeDeclarationInfo? typeInfo)
        {
            if (typeInfo is null) return;
            if (typeInfo.Value.Diagnostic is not null)
            {
                context.ReportDiagnostic(typeInfo.Value.Diagnostic);
                return;
            }

            var sourceCode = GenerateSource(typeInfo.Value);
            context.AddSource($"{typeInfo.Value.Name}.g.cs", SourceText.From(sourceCode, Encoding.UTF8));
        }

        private static string GenerateSource(TypeDeclarationInfo info)
        {
            var sb = new StringBuilder();
            sb.AppendLine("// <auto-generated/>");
            sb.AppendLine("#pragma warning disable");

            bool hasNamespace = !string.IsNullOrEmpty(info.Namespace);
            if (hasNamespace)
            {
                sb.AppendLine($"namespace {info.Namespace}");
                sb.AppendLine("{");
            }

            var indent = new Indent(hasNamespace ? 1 : 0);

            if (info.ParentClasses != null)
            {
                foreach (var parentClass in info.ParentClasses)
                {
                    sb.AppendLine($"{indent}public partial class {parentClass}");
                    sb.AppendLine($"{indent}{{");
                    indent.Increment();
                }
            }

            sb.AppendLine($"{indent}[global::System.Serializable]");
            sb.AppendLine($"{indent}[global::Unity.IL2CPP.CompilerServices.Il2CppSetOption(global::Unity.IL2CPP.CompilerServices.Option.NullChecks, false)]");
            sb.AppendLine($"{indent}[global::Unity.IL2CPP.CompilerServices.Il2CppSetOption(global::Unity.IL2CPP.CompilerServices.Option.ArrayBoundsChecks, false)]");
            sb.AppendLine($"{indent}[global::Unity.IL2CPP.CompilerServices.Il2CppSetOption(global::Unity.IL2CPP.CompilerServices.Option.DivideByZeroChecks, false)]");

            string typeKeyword = info.IsStruct ? "struct" : "class";
            sb.AppendLine($"{indent}public partial {typeKeyword} {info.Name}");
            sb.AppendLine($"{indent}{{");
            sb.AppendLine($"{indent}}}");

            if (info.ParentClasses != null)
            {
                foreach (var _ in info.ParentClasses)
                {
                    indent.Decrement();
                    sb.AppendLine($"{indent}}}");
                }
            }

            if (hasNamespace)
            {
                sb.AppendLine("}");
            }

            sb.AppendLine("#pragma warning restore");
            return sb.ToString();
        }

        private static List<string> GetParentClassHierarchy(TypeDeclarationSyntax typeSyntax)
        {
            var hierarchy = new List<string>();
            for (var parent = typeSyntax.Parent; parent is ClassDeclarationSyntax classSyntax; parent = classSyntax.Parent)
            {
                hierarchy.Add(classSyntax.Identifier.Text);
            }
            hierarchy.Reverse();
            return hierarchy.Count > 0 ? hierarchy : null;
        }

        private class Indent
        {
            private int _level;
            public Indent(int initialLevel) => _level = initialLevel;
            public void Increment() => _level++;
            public void Decrement() => _level--;
            public override string ToString() => new string(' ', _level * 4);
        }

        private readonly struct TypeDeclarationInfo
        {
            public readonly string Name;
            public readonly string Namespace;
            public readonly List<string> ParentClasses;
            public readonly bool IsStruct;
            public readonly Diagnostic Diagnostic;

            public TypeDeclarationInfo(string name, string ns, List<string> parentClasses, bool isStruct)
            {
                Name = name;
                Namespace = ns;
                ParentClasses = parentClasses;
                IsStruct = isStruct;
                Diagnostic = null;
            }

            public TypeDeclarationInfo(Diagnostic diagnostic)
            {
                Name = string.Empty;
                Namespace = string.Empty;
                ParentClasses = null;
                IsStruct = false;
                Diagnostic = diagnostic;
            }
        }
    }
}